/* Version 0.1 */
#define MAX_SET 30
#define MAX_MOD (MAX_SET * (MAX_SET - 1) + 1)

#define false 0
#define true 1

#define FOREVER for (;;)

#define MAX_ITERATIONS 100000

typedef struct {
    int k;
    int m;
    int low;
    int max_candidate;
    int current;
    int *set;
    int *diffs;
} PUSH_CONTEXT;

int push(int a, PUSH_CONTEXT *pc);
int pop(PUSH_CONTEXT *pc);

__kernel void kmain(
    int k,
    int prefix_size,
    __global int *prefix,
    __global int *status,
    __global int *output)
{
    int set[MAX_SET];
    int diffs[MAX_MOD];
    PUSH_CONTEXT pc;
    int candidate;

    size_t worker_id = get_global_id(0);
    size_t local_id = get_local_id(0);

    if (k > MAX_SET) {
        status[local_id] = -1;
        return;
    }
    status[local_id] = -2;

    pc.current = 0;
    pc.low = 0;
    pc.set = set;
    pc.diffs = diffs;
    pc.k = k;
    pc.m = k * (k - 1) + 1;

    diffs[0] = true;

    if (prefix_size == 0) {
        push(0, &pc);
        push(1, &pc);
    } else {
        for (int i = 0; i < prefix_size; i++) {
            push(prefix[i], &pc);
        }
    }

    status[local_id] = -3;

    unsigned int seed = worker_id + 3;
    if (!push(seed, &pc)) {
        status[local_id] = -4;
        return;
    }

    return;

    candidate = set[pc.current - 1] + pc.low + 1;
    int min_size = pc.current;

    int iterations = 0;
    status[local_id] = -5;
    FOREVER {
        iterations++;
        if (iterations >= MAX_ITERATIONS) {
            status[local_id] = -6;
            return;
        }

        // if candidate is feasible, push on
        if (push(candidate, &pc)) {
            if (pc.current == k) {
                for (int i = 0; i < k; i++) {
                    output[i] = pc.set[i];
                }
                status[local_id] = iterations;
                return;
            }
            candidate += pc.low + 1;
            continue;
        }

        // n is not feasible - try next value
        candidate++;

        // Can't work - backtrack
        if (candidate >= pc.max_candidate) {
            if (pc.current < min_size) {
                status[local_id] = iterations;
                return;
            }
            candidate = pop(&pc) + 1;
        }
    }
}

int push(int a, PUSH_CONTEXT *pc) {
    int d;

    for (int i = 0; i < pc->current; i++) {
        d = a - pc->set[i];
        if (d > pc->m / 2) {
            d = pc->m - d;
        }
        if (pc->diffs[d]) {
            for (int j = 0; j < i; j++) {
                d = a - pc->set[j];
                if (d > pc->m / 2) {
                    d = pc->m - d;
                }
                pc->diffs[d] = false;
            }
            return false;
        }
        pc->diffs[d] = true;
    }
    pc->set[pc->current++] = a;

    while (pc->low < pc->m / 2 && pc->diffs[pc->low + 1]) {
        pc->low++;
    }

    pc->max_candidate = pc->m - pc->low - (pc->low + 1) * (pc->k - pc->current - 1);

    return true;
}

int pop(PUSH_CONTEXT *pc) {
    int a = pc->set[--pc->current];

    for (int i = 0; i < pc->current; i++) {
        int d = a - pc->set[i];
        if (d > pc->m / 2) {
            d = pc->m - d;
        }
        pc->diffs[d] = false;
        if (d <= pc->low) {
            pc->low = d - 1;
        }
    }

    pc->max_candidate = pc->m - pc->low - (pc->low + 1) * (pc->k - pc->current - 1);

    return a;
}
